STAP (Simple Task-Actor Protocol)
version 5.2

    STAP is a machine-readable format for specifying user-interface changes.
    Main focus of STAP is in providing symmetric task experience for human and computational users alike.
    In its focus to make human software usable by machine agents, STAP aims to eliminate non-task-essential design choices (e.g. font type/size may be irrelevant for may task types), leaving those to be optionally specified via customizable templates (e.g. CSS).
    STAP messages adhere to JSON formatting, and can thus be deserialized with any standard JSON library.
    
    Deploying a STAP application is similar to deploying a web application, where STAP is employed in place of HTML.
    Much like HTML, STAP is a means for serializing task interface display and interactions.
    Unlike HTML documents, STAP messages are incremental updates to the display (the implication is that STAP applications require task-side push ability (e.g. using websockets), or continuous user-side requests).
    Whereas HTML is focused on hypertext look and feel, STAP is focused on function and structure of task interface.
    Thus, STAP employs many fewer directives than there are tags in HTML.

        STAP DIRECTIVE      HTML EQUIVALENT
        _tb                 <table>
        _ln                 <path> element inside <svg>
        _i                  set of <input type=button> (or <button> or <a> or <div> or <span>) elements that send onclick events
        _ih                 set of <input type=button> (or <button> or <a> or <div> or <span>) elements that send onmousedown and onmouseup events
        _i1                 set of <option> elements inside <select>, or set of <input type="radio"> elements sharing a name
        _i2                 set of <option> elements inside <select multiple>, or set of <input type="checkbox"> elements
        _ix                 <input> or <textarea> or <input type=password>
        _i^                 no HTML equivalent


///////////////////////////////////////////////////////////////////
Examples:

    -> ::= Message sent from task software to participant software
    <- ::= Message sent to task software from participant software

    Sample Interaction 1:
        // display "Hello World"
        -> "Hello World"
        // display a ">" prompt with a textbox
        -> {">":["_ix"]}
        // user typed "hi" into the textbox after 30.8s
        <- [30800,">","hi"]

    Sample Interaction 2:
        // display "Hello World"
        -> "Hello World"
        // let client know that a goal in this task is to maximize coins earned
        -> {"_task":{"good":{"Coins Earned":"+"}}}
        // display two buttons
        -> {"choose a button":["_i","Button 1","Button 2"]}
        // first button was clicked after 2.307sec
        <- [2307,"choose a button",{"Button 1":3}]
        // give client reward, "Coins Earned"=7
        -> {"Coins Earned":7}
        // wait 2 seconds and remove the coins earned display
        -> {"_S":4307,"Coins Earned":null}
        // second button was clicked
        <- [5422,"choose a button",{"Button 2":3}]
        // give reward
        -> {"Coins Earned":3}
        ...

    Sample Interation 3:
        // display a 100x100 box, with an element inside it that will display red lines
        -> {"click somewhere":{"_bx":{"w":100,"h":100},"_i+":[3],"#lines":{"_ln":{"c":"red"}}}}
        // user clicked in location 24,60 relative to top-left corner of the box
        <- [1570,"click somewhere",[3,24,60]]
        // draw a line from middle of the box to where user clicked
        -> {"_.":{"#lines":{"#0":[50,50,24,60]}}}
        // user clicked in location 91,10 relative to top-left corner of the box
        <- [2307,"click somewhere",[3,91,10]]
        // draw a line from middle of the box to where user clicked
        -> {"_.":{"#lines":{"#1":[50,50,91,10]}}}
        // user clicked in location 31,33 relative to top-left corner of the box
        <- [2555,"click somewhere",[3,31,33]]
        // draw a line from middle of the box to where user clicked
        -> {"_.":{"#lines":{"#2":[50,50,31,33]}}}
        ...


    Input       Sampe Control definition (->)                             Sample Actions (<-)
    -------------------------------------------------------------------------------------------------------------------
    button      {"#abc":{"_i":{},"press me":1}}                           [1012,"#abc",{"press me":3}]
    button      {"#abc":["_i","press me"]}
    holddown    {"#abc":{"_ih":{},"hold me":1}}                           [1012,"#abc":{"hold me":2}] [1323,"#abc":{"hold me":1}]
    holddown    {"#abc":["_ih","hold me"]}
    select      {"#abc":{"_i1":{},"male":1,"female":1}}                   [1012,"#abc":{"male":2}] [1323,"#abc",{"female":2}] [1703,"#abc",{"female":1}]
    select      {"#abc":["_i1","subaru","tesla"]}
    onoff       {"#abc":{"_i2":{},"subaru":1,"tesla":1}}                  [1012,"#abc",{"male":2}] [1323,"#abc":{"female":2}] [1703,"#abc",{"male":1}] [2301,"#abc",{"female":1}]
    onoff       {"#abc":["_i2","subaru","tesla"]}
    text        {"#abc":{"_ix":{}}}                                       [1012,"#abc","hello world"]
    events      {"#abc":{"_i+":[2,16],...}}                               [1012,"#abc",[2,x,y]] [1323,"#abc",[16,x,y]]





///////////////////////////////////////////////////////////////////
Definition:
    -> ::= Message sent from task software to participant software
    <- ::= Message sent to task software from participant software

->::= <<state>>                                                         //edit current display state recursively with values in <<state>>
->::= {"_.":{<<key>>:<<element>>}}                                      //find first occurrence of <<key>> in existing display state hierarchy, edit its value based on <<element>>
->::= <<text>>                                                          //shorthand for {"_a":<<text>>}; append <<text>> to display; e.g. "hello world" "goodbye world" is equivalent to {"_a":"hello world"} {"_a":"goodbye world"}, and will append "hello world" and then "goodbye world" text strings to the virtual display
->::= null                                                              //shorthand for {"_*":null}; clear the display state
->::= 0                                                                 //shorthand for {"_Z":0}; end of stream flag; indicates that there are no more display updates until user input

<-::= [<<ums>>,<<key>>,<<actionValue>>]                                 //<<key>> corresponds to an actionable item key (e.g. button panel, textbox)
<-::= [<<ums>>,<<tweenID>>,0]                                           //signifies that a requested timeout or animation is finished (or virtually finished for faster-than-real-time computational simulations)
<-::= [<<ums>>,"_R",<<msgID>>]                                          //receipt of msg; signifies that task->actor msg with the specified <<msgID>> has been processed
<-::= [<<ums>>,"_error",<<text>>]                                       //error message
<-::= [<<ums>>,"_ver",<<number>>]                                       //version of STAP expected by client software

<<ums>>::= <<number>>                                                   //time in milliseconds since the inintiation of user software (e.g. onload event)
<<msgID>>::= <<number>>                                                 //integer indicating task->actor message number, starting at 1
<<state>>::= {(<<key>>:<<element>>,)*}                                  //unordered declaration of key/element pairs
<<state>>::= [(<<key>>|([<<key>>,<<element>>]),)+]                      //declare key/element pairs in order; if key is specified without an element, and if this key does not exist, set its resepective element to default value (usually "", but could be {} if <<key>> is an <<option>>, or 1 if <<key>> is inside an _i, _i1, or _i2 element)
<<element>>::= <<state>>|<<text>>|<<number>>|null                       //null signifies key deletion
<<element>>::= ** if key is one of the <<option>> keys below, the respective <<element>> must adhere to the <<option>> description **
<<text>>::= ** see JSON string specification, e.g. http://json.org **
<<number>>::= ** see JSON number specification, e.g. http://json.org **
<<key>>::= ** legal JSON string; empty-string not allowed **            //if <<key>> string begins with #, it is hidden; if <<key>> begins with "_" the the <<key>>:<<element>> pair is hidden; if <<key>> is one of <<option>> keys below, it is a special directive to be processed prior to display
<<actionValue>>::=  ** must be one of the values that is allowed for the respective input type (e.g. _ix action value is <<text>>) **
<<tweenID>>::= <<text>>|<<number>>                                      //animation ID, see <<aniOption>> description below for more detail

**root-level only**
<<option>>::= "_error":<<text>>                                         //error messages
<<option>>::= "_ver":<<number>>                                         //may be sent once before task begins; version of the STAP used by task software
<<option>>::= "_template":<<url>>                                       //may be sent once before task begins; may be ignored by computational agents; url of a custom visualization template for STAP messages (e.g. CSS or JS file); may be used multiple times to load multiple template files
<<option>>::= "_unloadwarn":<<text>>                                    //may be sent once before task begins; may be ignored by computational agents; text to display in case participant is accidentally or intentionally closing the STAP display page or navigating away from it (e.g. "Navigating away from this page will pause your task session, your progress will be saved. Use your participant ID next time to resume.")
<<option>>::= "_task":{"(win)|(loss)|(end)":<<conds>>}                  //may be sent once before task begins; win, loss, and neutral task-end conditions; 
<<option>>::= "_task":{"(good)|(bad)":<<conds>>                         //may be sent once before task begins; goal values, e.g. {"good":{<<key>>:"correct"}} means that the <<key>>="correct" condition is a goal-state, {"bad":{<<key>>:"incorrect"}} means that the <<key>>="incorrect" is a condition to avoid, {"good":{<<key>>:1}} means <<key>> values closer to 1.0 are better, {"good":{<<key>>:"+"}} means higher numbers are better, {"good":{<<key>>:"-"}} means lower numbers are better
<<option>>::= "_replace":{(<<text>>:<<html>>,)+}                        //may be sent once before task begins; may be ignored by computational agents; replace shorthand text with longer text/html (can be used for special characters, icons, sound, images, movies, etc.); used to save bandwidth/processing and make things nice looking in gui, rather than to add meaningful information (e.g. to replace certain words with icon equivalents); Example:  {"_replace":{":)":"<img src=smiley.gif>"}} would signify that whenever ":)" is found in text, it is to be replaced with the smiley.gif image
<<option>>::= "_clientinfo":[(<<clientInfo>>,)*]                        //may be sent once before task begins; request information about the participant; participant replies to this request as such: {"_clientinfo":<<json>>}, e.g. {"_clientinfo":{"ip":"129.84.2.65","url":"http://localhost:8080/stap.html","screen":{"availWidth":1524,"availHeight":900,"width":1600,"height":900,"colorDepth":24,"pixelDepth":24,"availLeft":0,"availTop":0,"orientation":{"angle":0}},"userAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36"}}
<<option>>::= "_pp":<<state>>                                           //popup
<<option>>::= "_R":0|1                                                  //receipt flag; "_R":0 indicates that a receipt is required for the current msg, "_R":1 indicates that a receipt is required for every msg; receipt from user sw will be initiated on the completion of message processing, and will be in the format [<<ums>>,"_R",<<msgID>>]
<<option>>::= "_S":<<ums>>                                              //start time flag; used to delay the processing of the current state until user time is has reached specified <<ums>>
<<option>>::= "_S":[<<msgID>>,null|<<ums>>]                             //start time reset; used to update to prior _S directive, either to reset a timer, or, if null, destroy the queued message; e.g., if the 10th task->actor msg included "_S":10000, requesting a delay of msg processing until usertime is at 10s, "_S":[10,5000] will reset the delay on that same msg till user-time is 5s, and "_U":[10,null] will destroy that msg
<<option>>::= "_Z":0|1                                                  //end of stream flag; "_Z":0 indicates that there are no more display updates until user input; "_Z":1 indicates that user input is required after every task-message (this is similar to HTTP, where no server push occurs until a new GET/POST message from client); _Z is only useful in synchronous user-pull communication setup (e.g. HTTP, AJAX)
**any state**
<<option>>::= "_\*":<<element>>                                         //for each key in state, set value to <<element>>
<<option>>::= "_a":<<state>>|<<text>>|<<number>>                        //_a is the append directive; this directive is shorthand for "#<<X>>":<<state>>|<<text>>|<<number>> where <<X>> starts at zero and is incremented with each message, e.g. {"_a":"hello world"} {"_a":"goodbye world"} is equivalent to {"#0":"hello world"} {"#1":"goodbye world"}
<<option>>::= "_nm":{(<<numOption>>,)*}                                 //these are numeric options (e.g. min, max, flt precision), and apply to element where _nm directive is found, as well as all sub-elements
<<option>>::= "_bx":{(<<divOption>>,)*}                                 //box formatting options, useful where visualization is task-relevant
<<option>>::= "_i\+":[(<<eventType>>,)*]                                //capture/send element events like keyspresses and mouse movements; this list is concatenated w/ previously specified events; {"_i+":null} will clear event capturing on the element; each _i+ event return value is a JS array (see specifics in the <<eventType>> spec below)
<<option>>::= "_T":<<aniOptions>>                                       //signifies that values in the state are set via animation (Tween), not instantly; e.g. {"X":100,"_T":2} signifies that "X" is incremented/decremented till it reaches 100 over the span of 2 seconds; {<<key>>:null,"_T":2} signifies key removal is animated over 2 second span; {<<key>>:"","_T":2} signifies that key value is cleared over 2 second span; {<<key>>:"hello","_T":2} signifies that key value is cleared and then replaced with "hello" over a 2 second span
**special states**                                                      //state that contains one of these directive is NOT expected to contain <<key>>:<<element>> pairs, rather only <<key>>:<<number>>|<<text>>, and <<key>>:[...] pairs, depending on the <<option>>
<<option>>::= "_i":{(<<inputOption>>,)*}                                //clickable buttons, e.g. <<key>>:{"_i":{},"button 1":1,"button 2":1} creates two buttons, will sends back {<<key>>:{"button 1":3}} or {<<key>>:{"button 2":3}} when one of those buttons is clicked
<<option>>::= "_ih":{(<<inputOption>>,)*}                               //hold-down buttons, e.g. <<key>>:{"_ih":{},"button 1":1,"button 2":1} creates two buttons, will sends back {<<key>>:{"button 1":2}} when first button is pressed down, and {<<key>>:{"button 1":1}} when it lets go
<<option>>::= "_i1":{(<<inputOption>>,)*}                               //all elements in this state are exclusive choices (e.g. radiobuttons, select); when item is selected, the return value is 1 (same as button-down), when item is explicitly deselected, return value is 2 (same as button-up); when a new item is selected, previously selected value is assumed to be deselected implicitly; optionally, the first <<key>> in this element that has value 1 is the default selected item; e.g. {"_i1":{},"Male":2,"Female":2}
<<option>>::= "_i2":{(<<inputOption>>,)*}                               //all elements in this state are boolean choices (e.g. multiple checkboxes or multi-select); when item is selected/on, the return value is 2 (same as button-down), when item is deselected/off, return value is 1 (same as button-up); for each <<key>> in this element, the value (2 or 1) is the default value; e.g. {"_i2":{},"Ford":1,"GM":1,"Subaru":2,"Tesla":2}
<<option>>::= "_ix":{(<<inputOption>>,)*}                               //text input; e.g. <<key>>:["_ix"], user sends {<<key>>:<<text value>>} to task when text value is changed, task sw can alter text in existing textbox by using <<key>>:<<text>>, or <<key>>:{"_ix":{},"#0":<<text>>} (this latter version is a convinient way to specify default text when _ix is defined)
<<option>>::= "_i^":{(<<navOption>>,)*}                                 //element is a set of directional hold-down buttons; by default it has 4 directions, North, East, South, and West; button-down (onmousedown or ontouchstart) events send {<<key>>:{<<direction>>:2}} to client software and button-up (onmouseup or ontouchend) send {<<key>>:{<<direction>>:1}}, where <<direction>> is a number between 0 and the number of directions, e.g. a N/E/S/W control defined as <<key>>:{"_i^":{}} would send back {<<key>>:{"0":2}}, {<<key>>:{"1":2}}, {<<key>>:{"2":2}}, {<<key>>:{"3":2}} for N/E/S/W button-down events, respectively; only one direction may be pressed down at a time, thus a button-down event for North direction that follows a button-down event for East direction signifies not only that North is selected, but also that East is no longer selected
<<option>>::= "_ln":{(<<strokeOption>>,)*}                              //all elements in this state are lines/paths; expected state content: (<<key>>:[<<number>>,<<number>> (,<<number>>,<<number>>)+],)* pairs to signify line points, or <<key>>:<<text>> pairs to signify SVG path strings (e.g. <<key>>:"M150 0 75 200 225 200 Z")
<<option>>::= "_tb":{(<<tableOption>>,)*}                               //all elements in this state are rows in a table; expected state content: <<key>>:<<array>> pairs, where each <<array>> is a row of values; e.g. {"My Table":{"_tb":{},"#1":["John","male"],"#2":["Mary","female"]}}; alternatively, a 2dim array can be passed after the element is declared as a table; e.g. {"My Table":{"_tb":{}}} ... {"My Table":[["John","male"],["Mary","female"]]}

<<url>>::=          ** legal url **
<<html>>::=         ** legal text/html **
<<clientInfo>>::=   "url"
<<clientInfo>>::=   "ip"
<<clientInfo>>::=   "userAgent"
<<clientInfo>>::=   "screen"
<<conds>>::=        {(<<key>>:<<text>>|<<number>>,)*}
<<tableOption>>::=  "head":0|1                                          //if this value is 1, first row is treated as the header row (default value is 0)
<<strokeOption>>::= "f":(<<color>>|"none")                              //similar to SVG fill
<<strokeOption>>::= "c":(<<color>>|"none")                              //similar to SVG stroke
<<strokeOption>>::= "w":<<number>>                                      //similar to SVG stroke-width
<<strokeOption>>::= "(start)|(end)":"(arrow)|(circle)|(square)|()"      //similar to SVG marker-start/marker-end
<<strokeOption>>::= "cap":"(square)|(round)|(butt)"                     //similar to SVG stroke-linecap
<<strokeOption>>::= "dash":<<strokeDash>>                               //similar to SVG stroke-dasharray
<<inputOption>>::=  "disabled":0|1                                      //disable/enable input
<<inputOption>>::=  "oninput":1|0|-1|<<text>>                           //what to do after action is clicked/chosen/submitted: 1: leave as is, 0: disable, -1: clear, <<text>>: replace control with <<text>>
<<inputOption>>::=  "lines":<<number>>                                  //if action is _ix, i1, or i2, this specifies number of visible lines or items
<<inputOption>>::=  "maxchars":<<number>>                               //if action is _ix, this specifies max number of characters
<<inputOption>>::=  "pwd":<<text>>                                      //if action is _ix, this turns the field into a password field, and <<text>> specifies salt to add to the password string before using SHA1 to hash it before sending (salt must be consistent for a given user; see https://en.wikipedia.org/wiki/Salt_(cryptography))
<<navOption>>::=    "n":<<number>>                                      //number of directional hold-down buttons in the _i^ control; e.g. "_i^":{"n":2} creates a control that has 2 buttons (North and South), "_i^":{"n":8} creates a control that has 8 buttons (N,NE,E,SE,S,SW,W,NW)
<<navOption>>::=    "start":<<number>>                                  //angle (in degrees, where 0 is north) of the starting directional hold-down button in the _i^ control; e.g. "_i^":{"n":4,"start":45} creates a control that has NE, SE, SW, NW hold-down buttons
<<numOption>>::=    "time":<<timeFormat>>                               //exclusive with "unit" option; convert number of seconds since 1970/01/01 00:00 into datetime format such as "dddd h:mmtt d MMM yyyy", "M/d/y", "HH:mm:ss", "hh:mm:ss", "yy/M/d", "ddd MMM d h:mm"
<<numOption>>::=    "unit":<<text>>                                     //exclusive with "time" option; unit for the number (e.g. "$", "%", " m/sec", "kg")
<<numOption>>::=    "rnd":<<number>>                                    //round to the nearest <<number>>; e.g. {"_nm":{"rnd":.01}, "x":57.1} should be interpreted as x=57.10, {"_nm":{"rnd":5}, "x":57.1} should be interpreted as x=55
<<numOption>>::=    "<=":<<number>>                                     //minimum value
<<numOption>>::=    ">=":<<number>>                                     //maximum value
<<numOption>>::=    "=":<<number>>                                      //default/starting value
<<divOption>>::=    "w":<<number>>, "h":<<number>>                      //width/height of the box
<<divOption>>::=    "x":<<number>>, "y":<<number>>                      //position of left-top corner of the graphics area
<<divOption>>::=    "r":<<number>>                                      //rounded corner radius (ex: create a circle w/ radius=10 -> {"_bx":{"w":20,"h":20,"r":10}})
<<divOption>>::=    "rot":<<number>>                                    //rotation
<<divOption>>::=    "bg":<<cssBackground>>                              //background
<<divOption>>::=    "bd":<<cssBorder>>                                  //border style
<<divOption>>::=    "bdc":<<color>>                                     //border color
<<divOption>>::=    "bdw":<<number>>                                    //border width
<<divOption>>::=    "pad":<<cssPadding>>                                //padding
<<divOption>>::=    "fnt":<<cssFont>>                                   //font for text displayed inside the graphics area
<<divOption>>::=    "col":<<color>>                                     //color for text displayed inside the graphics area
<<divOption>>::=    "_T":<<aniOptions>>                                 //signifies that <<divOption>> values are not set instantly, but rather via animation (Tween)
<<divOption>>::=    "autoscroll":0|1                                    //"autoscroll":1 signifies that contents automatically scroll down to show the latest key:element added to the state; replaces deprecated directive 
<<aniOptions>>::=   {(<<aniOption>>,)*}
<<aniOption>>::=    "s":<<number>>                                      //number of seconds to animate
<<aniOption>>::=    "ease":(0|1|2|3|4|"back"|"elastic"|"bounce")        //easing option for animation; default is 0 (linear); see http://greensock.com/ease-visualizer to visualize ease options
<<aniOption>>::=    "easeout":(1|-1|0)                                  //ease direction; 1 is out, -1 is in, 0 is in-and-out; default is 1; see http://greensock.com/ease-visualizer to visualize ease options
<<aniOption>>::=    "tid":<<tweenID>>                                   //tween ID; if specified, this tween can later be altered in midst of animation, and actor sw will send back {<<tweenID>>:0} when animation finishes
<<eventType>>::=    1                                                   //mouseup (or touchend) event; sends [1,<<number>>,<<number>>], signifying mouse-up and its location
<<eventType>>::=    2                                                   //mousedown (or touchstart) event; sends [2,<<number>>,<<number>>], signifying mouse-down and its location
<<eventType>>::=    3                                                   //click event; sends [3,<<number>>,<<number>>], signifying a click, and its location
<<eventType>>::=    4                                                   //dblclick event; sends [4,<<number>>,<<number>>], signifying a double-click, and its location
<<eventType>>::=    8                                                   //mousemove event; sends [8,<<number>>,<<number>>], signifying mouse location
<<eventType>>::=    16                                                  //mouseenter event; sends [16,<<number>>,<<number>>], signifying mouse-enter, and its location
<<eventType>>::=    32                                                  //mouseleave event; sends [32,<<number>>,<<number>>], signifying mouse-leave, and its location
<<eventType>>::=    64                                                  //keydown event; sends [64,<<keycode>>]
<<eventType>>::=    128                                                 //keyup event; sends [128,<<keycode>>]
<<eventType>>::=    192                                                 //keypress event; sends [192,<<keycode>>]
<<color>>::=        ** see CSS color specification, e.g. http://www.w3schools.com/cssref/css_colors.asp **
<<cssBackground>>::=** see CSS background specification, e.g. http://www.w3schools.com/cssref/css3_pr_background.asp **
<<cssBorder>>::=    ** see CSS border style specification, e.g. http://www.w3schools.com/cssref/pr_border.asp **
<<cssFont>>::=      ** see CSS font specification, e.g. http://www.w3schools.com/cssref/pr_font_font.asp **
<<strokeDash>>::=   ** see SVG stroke-dasharray specification, e.g. https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray **
<<keycode>>::=      ** javascript key code, e.g. http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes **
, ::=               ** commas trailing the last pair in an object or the last element in an array must be trimmed, see JSON members/elements specification, e.g. http://json.org **


/////////////////////////////////////////////////////////////////////////////////////////
//Potential future additions:
// <<conds>>::= [([<<cond>>+],)+]                                          //assume OR for all items in outer list, assume AND for all items in inner list
// <<cond>>::= "<<key>> (==|!=|<|>) <<text>>|<<number>>",                  //boolean statement signifying a potential game-end condition
// <<inputOption>>::=  "keys":([(<<keycode>>,)*])|{(<<key>>:<<keycode>>,)*}//keyboard shortcuts assigned to each input element (e.g. use 13 for carriage return, 65 for A, 37 for left arrow key)
// <<divOption>>::=    "opc":<<number>>                                    //opacity of the graphics area
// <<divOption>>::=    "scl":<<number>>                                    //scale factor for the graphics area
// <<eventType>>::=    "drag"                                              //same as 2 (mousedown) but allows element to be dragged with mouse/finger
// <<eventType>>::=    10                                                  //same as "drag" but also reports back all movement locations relative to top-left of the screen
// allow w/h (and any pixel) specification in terms of screen% and aspect ratios, e.g. w:90%, h:.5w
// <<tableOption>>::=  "rowgroup":{(<<text>>:[(<<key>>,)+],)+}             //row grouping; <<text>> corresponds to group name, each <<key>> corresponds to known row <<key>>
// <<tableOption>>::=  "colgroup":{(<<text>>:[(<<number>>,)+],)+}          //columng grouping; <<text>> corresponds to group name, each <<number>> corresponds to columnn number
// <<tableOption>>::=  "colw":[(<<number>>,)+]                             //array of column widths for a table
// <<tableOption>>::=  "rowh":[(<<number>>,)+]                             //array of row heights for a table
// <<tableOption>>::=  "bd":<<cssBorder>>                                  //cell border style
// <<tableOption>>::=  "bdc":<<color>>                                     //cell border color
// <<tableOption>>::=  "bdw":<<number>>                                    //cell border width
// <<tableOption>>::=  "pad":<<cssPadding>>                                //cell padding
// <<aniOption>>::=    ???? .... collision detection

**Notes:

could expand _R flag to send receipts on start of processing too, it'd come back as [<<ums>>,"_S",<<msgID>>]
or maybe start/stop times could be sent together: [<<ums>>,"_R",<<msgID>>,<<ums>>]
could maybe have separate _R and _S flags for requesting start/stop receipts?
_S should probly be used instead of current _W, but maybe _W could be kept too?
in either case, the sync flag should probly be _Q or _Z or something, not _S

**
