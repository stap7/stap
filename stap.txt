STAP (Simple Task-Actor Protocol)
version 6.03


    Message Type        Regular Expression                                  Functionality
    ** task -> user **  <<state>>                                           edit current display state with values in <<state>>
    ** task -> user **  null                                                clear the display state; shorthand for [[true,null]]
    ** task -> user **  {<<taskOption>>(,<<taskOption>>)*}                  optional task directives
    ** user -> task **  [<<ums>>,<<key>>,<<value>>]                         user-side action; <<key>> corresponds to element key that is manipulated by user (e.g. button, textbox), <<value>> must be of a type consistent with this element (e.g. for boolean elements value must be a boolean)
    ** user -> task **  [<<ums>>(,<<key>>)?,<<userEvent>>]                  user-side event

    Label Name          Regular Expression                                  Functionality
    <<state>>           [<<element>>(,<<element>>)*]                        array of elements
    <<element>>         <<value>>|<<key-item>>                              elements can be specified with key or without; elements specified without a key are always appended to the end of the <<state>>, i.e. [...,<<value>>,...] is shorthand for [...,["",<<value>>],...]
    <<key-item>>        [<<key>>(,<<item>>)?]                               key-item pair; if item is not specified, default is false (i.e. button or unselected option)
    <<item>>            <<state>>|<<value>>|null                            state, value, or null (null signifies deletion of key-item pair from the display)
    <<value>>           <<text>>|<<number>>|true|false
    <<key>>             ** non-empty <<text>> **                            displayable key; any words beginning with # in <<key>> text are hidden (hashtags); used for reference only //TODO: add way to escape #, e.g. ##
    <<key>>             ""                                                  empty string <<key>> signifies that the corresponding item should be appended without a key
    <<key>>             true                                                true is a wildcard key, signifying "for all existing keys"; e.g. [[true,0]] sets values of each existing element to 0; [[true,null,{"S":20000}]] signifies that all elements should be removed 20s after task begins; [[true,{"bg":"red"}]] signifies that all elements background color should be changed to red
    <<key>>             <<uint>>                                            numeric keys are row numbers (row numbering begins at 0); if <<uint>> is greater or equal to current number of rows in parent state, corresponding element is appended to this state
    <<ums>>             <<uint>>                                            time in milliseconds since the initiation of user software (e.g. onload event)
    <<text>>            ** see JSON string specification, e.g. http://json.org **
    <<number>>          ** see JSON number specification, e.g. http://json.org **
    <<uint>>            ** integer >= 0 **

everything above is core-STAP; all user sw must be able to handle the format specified above for simple text+button tasks

==

everything below specifies optional directives that enable more featureful user-interface interactions

    <<taskOption>>      "require":{<<required>>(,<<required>>)*}            should be sent once before task begins; specify which options and option values are required for correctly interpreting current task; if any of the <<required>> elements are not implemented yet in the user software, the suggested behavior is to disconnect from task after a polite {"error":"sorry, <<required>> is not yet implemented on this side :("}
    <<taskOption>>      "template":<<url>>|<<js>>                           likely sent once before task begins; may be ignored by computational agents; url of a custom visualization template for STAP messages (e.g. CSS or JS file); may be used multiple times to load multiple template files
    <<taskOption>>      "replace":{<<text>>:<<html>>(,<<text>>:<<html>>)*}  likely sent once before task begins; may be ignored by computational agents; replace shorthand text with longer text/html (can be used for special characters, icons, sound, images, movies, etc.); used to save bandwidth/processing and make things nice looking in gui, rather than to add meaningful information (e.g. to replace certain words with icon equivalents); Example:  {"_replace":{":)":"<img src=smiley.gif>"}} would signify that whenever ":)" is found in text, it is to be replaced with the smiley.gif image
    <<taskOption>>      "task":{"(win)|(loss)|(end)":<<conds>>}             likely sent once before task begins; win, loss, and neutral task-end conditions; suggested user-sw behavior for human participants is to convert <<conds>> into natural language and display as "Instructions"
    <<taskOption>>      "task":{"(good)|(bad)":<<conds>>}                   likely sent once before task begins; goal values (what to seek, what to avoid); suggested user-sw behavior for human participants is to convert <<conds>> into natural language and display as "Instructions"
    <<taskOption>>      "client":[<<clientInfo>>(,<<clientInfo>>)*]         likely sent once before task begins; request information about user-side software; the polite thing for user-side software to do would be to reply to "client" <<taskOption>> with as much information as possible, but task-side code should not be dependent on this; participant replies to this request as such: [<<ums>>,{"clientinfo":<<json>>}]; e.g. a response to {"clientinfo":["ip","url","screen","userAgent"]} may be [<<ums>>,{"clientinfo":{"ip":"129.84.2.65","url":"http://localhost:8080/stap.html","screen":{"availWidth":1524,"availHeight":900,"width":1600,"height":900,"colorDepth":24,"pixelDepth":24,"availLeft":0,"availTop":0,"orientation":{"angle":0}},"userAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36"}}]
    <<taskOption>>      "error":<<text>>                                    optional message to be dumped into user-side error stream
    <<conds>>           [<<cond>>|<<condAnd>>(,<<cond>>|<<condAnd>>)*]      <<conds>> list is True if any of the items in it are True
    <<condAnd>>         [<<cond>>(,<<cond>>)*]                              <<condAnd>> list is True if ALL of the items in it are True
    <<cond>>            [<<key>>(,"<|>|(<=)|(>=)|(!=)")?,<<number>>|<<text>>]
    <<clientInfo>>      "ip"                                                request client ip address
    <<clientInfo>>      "userAgent"                                         request information about user-side software (e.g. webbrowser type/version, AI architecture type/version)
    <<clientInfo>>      "url"                                               request client url (relevant when user-side software runs in a webbrowser)
    <<clientInfo>>      "screen"                                            find out total user screen size (for human participants this would be different from <<eventType>> 13, which only sends back current <<state>> size)
    <<userEvent>>       {"client":{(<<clientInfo>>:<<json>>,)+}}            response to "client" <<taskOption>>; e.g. a response to {"client":["ip","url","screen","userAgent"]} may be [<<ums>>,{"client":{"ip":"129.84.2.65","url":"http://localhost:8080/stap.html","screen":{"availWidth":1524,"availHeight":900,"width":1600,"height":900,"colorDepth":24,"pixelDepth":24,"availLeft":0,"availTop":0,"orientation":{"angle":0}},"userAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36"}}]
    <<userEvent>>       {"error":<<text>>}                                  user->task messages that contain this directive are dumped into task-side error stream
    <<userEvent>>       [0]                                                 load event. i.e. user-sw is ready
    <<userEvent>>       [1]                                                 beforeunload event, i.e. user-sw is quitting
    <<json>>            ** see full JSON specification, e.g. http://json.org **
    <<url>>             ** legal url **
    <<js>>              ** legal javascript **
    <<html>>            ** legal text/html **


everything above is core-STAP; although task-options can be ignored in many cases, user-sw must still expect them as potentially incoming messages, and be willing to quit if it cannot handle any of the items specified via the "require" task option

==

everything below can be negotiated via the "require" <<taskOption>>; if task requires options that user sw cannot handle, user can disconnect

- unless otherwise specified, each option value is inheritable; e.g. [["numbers",[1,2,["more",[3,4]]],{"rnd":1}]] signifies that all numeric values in "numbers", including those under "more", are rounded to 1 (integers)
- [element-specific] options are not inheritable
- [edit-specific] option values are not permanent; e.g. [["x","",{"T":10,"bg":"blue"}]] signifies that the background of "x" should be changed to blue over the course of 10seconds, after which the value of "bg" (background) remains "blue", but the value "T" (time of animation) resets to null, because "T" is an [edit-specific] option

    Label Name          Regular Expression                                  Functionality
    <<required>>        "options":[<<optionName>>(,<<optionName>>)*]        specify options necessary for this task; e.g., {"required":{"options":["r","rot"]}}
    <<required>>        "sizeUnits":["<<sizeUnit>>"(,"<<sizeUnit>>")*]      specify size-units necessary for this task; e.g., {"required":{"sizeUnits":["%","E","vh","vw"]}}
    <<required>>        "types":[<<elementType>>(,<<elementType>>)+]        specify element types necessary for this task; e.g., {"required":{"types":["popup","path"]}}; if "requiredTypes" is not empty, "type" does not need to be specified via {"required":{"options"...} -- it is assumed to be required
    <<required>>        "events":[<<eventType>>(,<<eventType>>)*]           specify event-capture capabilities necessary for this task; e.g., {"required":{"events":["keydown","mousemove"]}};  if "requiredEvents" is not empty, "e" does not need to be specified via {"required":{"options"...} -- it is assumed to be required
    <<optionName>>      ** the part on the left of the colon in the <<option>> or <<taskOption>> expression; e.g. "ins", "S", "eB", "bg" **

    <<taskOption>>      <<option>>
    <<taskOption>>      ".":<<key-item>>                                    find the key from <<key-item>> tuple in current display and edit its value/options to the value/options specified in <<key-item>> tuple; e.g. if the display was formed as follows, [["x",[["y",[["z",0]]]]]], then {".":["z",5]} would change it to [["x",[["y",[["z",5]]]]]]
    <<key-item>>        [<<key>>(,<<item>>)?(,<<options>>)?]                key-item specification with additional options
    <<element>>         <<options>>                                         element specified as <<options>> without a key or a value are assumed to be empty-string text elements

    <<options>>         {<<option>>(,<<option>>)*}                          [NOT part of core-STAP] optional element directives; any <<option>> type required in the task must be specified via the "require" <<taskOption>>
    <<option>>          "ins":<<uint>>                                      [edit-specific] insert current element at, or move to, row indicated by <<uint>> (row-numbering starts at 0); if <<uint>> is greater or equal to current number of rows in parent state, corresponding element is appended to this state; e.g. [["a","b"],["c","d"],["e","f"]] followed by [["x","y",{"ins":1}]] is equivalent to [["a","b"],["x","y"],["c","d"],["e","f"]]
    <<option>>          "S":<<ums>>|null                                    [edit-specific] start time flag (exclusive with "W" option); used to delay the processing of the current edits until user time has reached specified <<ums>>; null clears previous delays (initiated via "S" or "W" directive) for current element edits
    <<option>>          "W":<<number>>|null                                 [edit-specific] wait time flag (exclusive with "S" option); used to delay the processing of the current edits; <<number>> is the number of seconds to delay; null clears previous delays (initiated via "S" or "W" directive) for current element edits; e.g. [["text","hello"],["text",null,{"W":2}]] would add "text":"hello" to screen, and then remove it 2 seconds later
    <<option>>          "T":<<number>>|null                                 [edit-specific] animate (Tween) flag; <<number>> is the number of seconds to animate the current edits; null clears current animations
    <<option>>          "R":<<receiptType>>                                 [edit-specific] receipt flag for current edit
    <<option>>          "@":<<key>>                                         [edit-specific] optional <<key>> for current edit (rather than the element being edited); useful for edits that employ S, T, or R flags; e.g. the following four task->user messages -- [["candles",0]] [["candles",1,{"@":"@t1","S":10000,"R":3}]] [["candles",2,{"@":"@t2","S":20000,"R":3}]] [["@t1",{"S":null}]] -- would result in a key:value pair "candles":0 being added to display, and timers set up to change the value of "candles" to 1 at 10sec, then to 2 at 20sec into the task, then the 10sec timer is removed, but the 20sec timer for the same element remains, and user sw ends up sending the following back to task -- [<<ums>>,"@t1",{"R":1}] [<<ums>>,"@t2",{"R":1}] [20000,"@t2",{"R":2}]
    <<option>>          <<inputOption>>                                     user-input options (specify whether element value is editable, and what the behavior is upon edits)
    <<option>>          <<stateOption>>                                     state element options
    <<option>>          <<boolOption>>                                      boolean element options
    <<option>>          <<numOption>>                                       number element options
    <<option>>          <<txtOption>>                                       text element options
    <<option>>          <<boxOption>>                                       [element-specific] style options; these options should be used only when needed for the task to function correctly, never merely for visual appeal (visual appeal specifications are loaded via templates, using <<taskOption>> "template":<<url>>)
    <<option>>          <<aniOption>>                                       animation options

    <<option>>          "type":<<elementType>>                              [element-specific] the value specified for this element 
    <<elementType>>     "popup"                                             this element is a popup -- a special <<state>> that pops up over other elements of the parent state, partially obscuring their view, and preventing them from being edited
    <<elementType>>     "table"                                             this element is a table -- a special <<state>> that contains others <<state>> elements, each of which will be a row in a table; e.g. [["my table",[[0,["name","age","gender"]],[1,["vlad",39,"m"]],[2,["mary",28,"f"]]],{"type":"table","head":1}]]
    <<elementType>>     "pie"                                               this element is a pie -- a special <<state>> whose elements are displayed as slices in a pie
    <<elementType>>     "path"                                              this element is a line/path -- its value is an array of numbers where each pair of numbers to signify line points, or <<text>> to signify SVG path string; e.g. [["my graph",[150,0,75,200,225,200],{"type":"path"}]] or [["my graph","M150 0 75 200 225 200 Z",{"type":"path"}]]
    <<option>>          <<tableOption>>                                     table element options
    <<option>>          <<pieOption>>                                       pie element options
    <<option>>          <<pathOption>>                                      path element options; these options should be used only when needed for the task to function correctly, never merely for visual appeal (visual appeal specifications are loaded via templates, using <<taskOption>> "template":<<url>>)

    <<inputOption>>     "onedit":<<item>>|<<options>>                       how to change editable element after user changes its value; use "onedit":{} to reset a control to do nothing after a user-directed change; e.g. [["say something","",{"eT":1,"onedit":""}]] will create a textbox where user can type something, but as soon as they hit Enter, the text will disappear; [["btn1",{"onedit":{"eB:0"}}]] creates a button, btn1, that becomes disabled once clicked; [["btn1",{"onedit":null}]] creates a button, btn1, that gets removed once clicked)
    <<inputOption>>     "onsubedit":<<item>>|<<options>>                    how to change state after one of its child elements receives user input; e.g. [["choose",[["choice 1"],["choice 2"]],{"select":1,"onsubedit":{"eB:0"}}]] creates a set of choices, which all become disabled once any one of them gets clicked
    <<inputOption>>     "onedit2":[<<item>>,<<options>>]                    same as "onedit", but both <<item>> and <<options>> are specified
    <<inputOption>>     "onsubedit2":[<<item>>,<<options>>]                 same as "onsubedit", but both <<item>> and <<options>> are specified
    <<inputOption>>     "eB":0|1                                            editable Boolean flag; 0 makes boolean elements (buttons) disabled; 1 (default) enables them
    <<inputOption>>     "eT":0|1|2|3|4                                      editable Text flag; 0 (default) is standard, non-editable text; non-zero value turns text elements into text inputs; 1 signifies that text-change event occurs on enter-key; 2 sends change when field loses focus; 3 sends change on both enter-key and blur; 4 sends change whenever any text in the field is altered
    <<inputOption>>     "eN":0|1|2|3|4                                      editable Number flag; 0 (default) is standard, non-editable text; non-zero value turns text elements into text inputs; 1 signifies that text-change event occurs on enter-key; 2 sends change when field loses focus; 3 sends change on both enter-key and blur; 4 sends change whenever any text in the field is altered
    <<inputOption>>     "e":[<<eventType>>(,<<eventType>>)*]                [element-specific] event capture; capture element events like key presses and mouse movements; event types required for task must be pre-specified via the "require" <<taskOption>>
    <<inputOption>>     "esu":"<<sizeUnit>>"                                size unit for x/y/w/h specs in user->task messages for captured events

    <<boolOption>>      "select":-1|0|1|2                                   selection behavior for boolean elements: -1 (default) means that each element is selected (true) on click, and considered deselected immediately (i.e. clickable buttons); 0 means that each element is selected (true) on mousedown, and deselected (false) on mouseup (i.e. hold-down buttons); 1 means that an element stays selected (true) when clicked, until it is clicked again to deselect (false), or until another element is selected in same state (i.e. radio buttons or select); 2 means that each element is selected (true) when clicked and deselected (false) when clicked again (i.e. checkboxes or multi-select)
    <<boolOption>>      "select":"n"                                        selection behavior for boolean elements: "n" is a hybrid between 1 and 0 -- only one element in state can be selected at a time, but the selection/deselection does not happen on click, but rather on mousedown/hover/mouseup  (e.g. a set of navigation buttons) -- each element is selected (true) either (1) on mousedown or (2) on mousehover while another boolean element in the same state is selected, and an element is deselected (false) either (1) on mouseup or (2) when mouse hovers over some other boolean element in the same state

    <<numOption>>       "rnd":<<number>>                                    round to the nearest <<number>>; e.g. {"_nm":{"rnd":.01}, "x":57.1} should be interpreted as x=57.10, {"_nm":{"rnd":5}, "x":57.1} should be interpreted as x=55
    <<numOption>>       "<=":<<number>>                                     minimum value
    <<numOption>>       ">=":<<number>>                                     maximum value
    <<numOption>>       "unit":<<text>>                                     exclusive with "time" option; unit for the number (e.g. "$", "%", "m/sec", "kg", "€ million", "$ k")
    <<numOption>>       "time":"(<<timeField>>)+"                           exclusive with "unit" option; indicates that the value for this element is the total number of seconds since 1970/01/01 00:00; e.g. [["when",1483963200,{"time":"YMDhm"}]] is a way to specify date/time 2017/01/09 12:00

    <<txtOption>>       "pwd":<<text>>                                      this turns a text input into a password field, and <<text>> specifies salt to append to the password string before using SHA256 to hash it before sending (this way user's intended passwords are never sent across the wire (this does not preclude the need to also salt/hash server-side); salt must be consistent for a given user; see https://en.wikipedia.org/wiki/Salt_(cryptography))
    <<txtOption>>       "no":<<text>>                                       <<text>> is a set of characters that are not allowed to be entered into the text element; e.g. "no":"\r\n"
    <<txtOption>>       "maxchars":<<number>>                               max number of characters in <<text>> or <<number>> element

    <<boxOption>>       "bg":<<cssBackground>>                              background
    <<boxOption>>       "c":<<color>>                                       text/stroke color
    <<boxOption>>       "fnt":<<cssFont>>                                   text font
    <<boxOption>>       "scroll":0|1|2                                      vertical scrolling; 0 - scrolling isn't allowed, 1 - scrolling allowed when possible, 2 - scrolling isn't allowed, but state automatically scrolls to the bottom to reveal newly added content, 3 - scrolling is allowed, and state automatically scrolls to the bottom to reveal newly added content
    <<boxOption>>       "scrollH":0|1|2                                     horizontal scrolling; 0 - scrolling isn't allowed, 1 - scrolling allowed when possible, 2 - scrolling isn't allowed, but state automatically scrolls to the right to reveal newly added content, 3 - scrolling is allowed, and state automatically scrolls to the right to reveal newly added content
    <<boxOption>>       "w":<<number>>|"<<number>><<sizeUnit>>"             width of the element
    <<boxOption>>       "h":<<number>>|"<<number>><<sizeUnit>>"             height of the element
    <<boxOption>>       "x":<<number>>|"<<number>><<sizeUnit>>"             horizontal position of left-top corner of the element
    <<boxOption>>       "y":<<number>>|"<<number>><<sizeUnit>>"             vertical position of left-top corner of the element
    <<boxOption>>       "z":<<number>>                                      z-index (stack order) of the element; an element with greater stack order is always in front of an element with a lower stack order
    <<boxOption>>       "r":<<number>>                                      rounded corner radius (ex: create a circle w/ radius=10 -> {"_bx":{"w":20,"h":20,"r":10}})
    <<boxOption>>       "rot":<<number>>                                    rotation
    <<boxOption>>       "bd":<<cssBorder>>                                  border style
    <<boxOption>>       "bdc":<<color>>                                     border color
    <<boxOption>>       "bdw":<<number>>                                    border width
    <<boxOption>>       "pad":<<cssPadding>>                                padding

    <<aniOption>>       "ease":(0|1|2|3|4|"back"|"elastic"|"bounce")        easing option for animation; default is 0 (linear); see http://greensock.com/ease-visualizer to visualize ease options
    <<aniOption>>       "easeout":(1|-1|0)                                  ease direction; 1 is out, -1 is in, 0 is in-and-out; default is 1; see http://greensock.com/ease-visualizer to visualize ease options

    <<tableOption>>     "head":0|1                                          if this value is 1, first row of a table is treated as the header row (default value is 0)

    <<pieOption>>       "bounda":[<<number>>(,<<number>>)*]                 bounding angles of the pie in clockwise order; e.g., [["navigation",[["E"],["S"],["W"],["N"]],{"type":"pie","bounda":[45,135,225,315]}]]

    <<pathOption>>      "f":(<<color>>|"none")                              similar to SVG fill
    <<pathOption>>      "thk":<<number>>                                    similar to SVG stroke-width
    <<pathOption>>      "arrow1|2":"(arrow)|(circle)|(square)|()"           similar to SVG marker-start/marker-end
    <<pathOption>>      "cap":"(square)|(round)|()"                         similar to SVG stroke-linecap
    <<pathOption>>      "dash":<<strokeDash>>                               similar to SVG stroke-dasharray

    <<userEvent>>       {"R":<<receiptType>>}                               response to "R" <<option>>; receipt message for edits corresponding to key of element being edited (or key of specific edit whenever "#" is specified)
    <<userEvent>>       [<<eventType>>(,<<value>>)*]                        captured UI events specified via the "e" option, see <<eventType>> descriptions below for more detail

    <<sizeUnit>>        ** legal CSS length unit; e.g., http://www.w3schools.com/cssref/css_units.asp **
    <<sizeUnit>>        E                                                   E signifies element size; when specifying height of <<state>> or <<table>>, E is row-height (e.g. {"h":"2.5E"} signifies that 2.5 rows will be visible in current state before scrolling down); when specifying width of <<state>> or <<table>>, E is element-width (e.g. {"w":"2.5E"} signifies that 2.5 elements will be visible in current state before scrolling right); when specifying height of a <<text>> element, E is (font height + space between lines) (e.g. {"h":"2.5E"} signifies that 2.5 lines of text will be visible in current element before scrolling down); when specifying width of a <<text>> element, E is (font width + space between characters) (e.g. {"w":"10E"} signifies that, if font-type is monospace, 10 characters will be visible; if font is not monospace, at least client promises to do its best).
    <<sizeUnit>>        w|h                                                 w/h signify element width and height; e.g., [["my box",{"w":100,"h":".5w"}]] makes the width/height of "my box" 100 and 50 pixels, respectively
    <<receiptType>>     1..7                                                1 indicates a receipt required when the message is received (receipt is sent as soon as the message is received, even if execution is delayed due to S flag); 2 indicates a receipt required when changes occur (if the change is animated, "R":2 indicates the beginning, not the end of animation); 4 indicates a receipt required at the end of the animation (if there is no animation, this is equivalent to "R":2); sums of these values indicate that multiple receipts are required (e.g. "R":3 is equivalent to having both, "R":1 and "R":2)
    <<eventType>>       0                                                   load event; user->task message on this event would be: [<<ums>>,<<key>>,[0]]
    <<eventType>>       1                                                   beforeunload event; user->task message on this event would be: [<<ums>>,<<key>>,[1]]
    <<eventType>>       10                                                  focus event; user->task message on this event would be: [<<ums>>,<<key>>,[10]]
    <<eventType>>       11                                                  blur event; user->task message on this event would be: [<<ums>>,<<key>>,[11]]
    <<eventType>>       12                                                  scroll event; user->task message on this event would be: [<<ums>>,<<key>>,[12],<<number>>]
    <<eventType>>       13                                                  resize event; user->task message on this event would be: [<<ums>>,<<key>>,[13,<<number>>,<<number>>]] where <<number>>,<<number>> is the width and height of the element; when this event is first assigned to an element, an immediate response is warranted
    <<eventType>>       14                                                  collision event; user->task message on this event would be: [<<ums>>,<<key>>,[14,<<key>>,<<number>>,<<number>>,<<number>>,<<number>>]] where <<key>> is the colliding element (which must also have collision-detection enabled), and <<number>>,<<number>>,<<number>>,<<number>> is the x,y,width,height of the overlapping rectangle, where x,y is from the top-left corner of current element
    <<eventType>>       20                                                  select event; user->task message on this event would be: [<<ums>>,<<key>>,[20,<<number>>,<<number>>]]
    <<eventType>>       21                                                  copy event; user->task message on this event would be: [<<ums>>,<<key>>,[21]]
    <<eventType>>       22                                                  cut event; user->task message on this event would be: [<<ums>>,<<key>>,[22]]
    <<eventType>>       23                                                  paste event; user->task message on this event would be: [<<ums>>,<<key>>,[23]]
    <<eventType>>       30                                                  keypress event; user->task message on this event would be: [<<ums>>,<<key>>,[30,<<number>>]], where <<number>> is the keycode
    <<eventType>>       31                                                  keydown event; user->task message on this event would be: [<<ums>>,<<key>>,[31,<<number>>]], where <<number>> is the keycode
    <<eventType>>       32                                                  keyup event; user->task message on this event would be: [<<ums>>,<<key>>,[32,<<number>>]], where <<number>> is the keycode
    <<eventType>>       40                                                  click event; user->task message on this event would be: [<<ums>>,<<key>>,[40,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       41                                                  dblclick event; user->task message on this event would be: [<<ums>>,<<key>>,[41,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       42                                                  mousedown event; user->task message on this event would be: [<<ums>>,<<key>>,[42,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       43                                                  mouseup event; user->task message on this event would be: [<<ums>>,<<key>>,[43,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       44                                                  mousemove event; user->task message on this event would be: [<<ums>>,<<key>>,[44,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       45                                                  mouseenter event; user->task message on this event would be: [<<ums>>,<<key>>,[45,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       46                                                  mouseleave event; user->task message on this event would be: [<<ums>>,<<key>>,[46,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       47                                                  mouseover event; user->task message on this event would be: [<<ums>>,<<key>>,[47,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<eventType>>       48                                                  mouseout event; user->task message on this event would be: [<<ums>>,<<key>>,[48,<<number>>,<<number>>]] where <<number>>,<<number>> is the x,y of the mouse from the top-left of element 
    <<timeField>>       Y|M|D|d|h|m|s|.                                     the characters "YMDdhms." correspond to Year, Month, Day, day of week, hours, min, sec, and milliseconds
    <<color>>           ** see CSS color specification, e.g. http://www.w3schools.com/cssref/css_colors.asp **
    <<cssBackground>>   ** see CSS background specification, e.g. http://www.w3schools.com/cssref/css3_pr_background.asp **
    <<cssBorder>>       ** see CSS border style specification, e.g. http://www.w3schools.com/cssref/pr_border.asp **
    <<cssPadding>>      ** see CSS border style specification, e.g. http://www.w3schools.com/cssref/pr_padding.asp **
    <<cssFont>>         ** see CSS font specification, e.g. http://www.w3schools.com/cssref/pr_font_font.asp **
    <<strokeDash>>      ** see SVG stroke-dasharray specification, e.g. https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray **

