STAP (Simple Task-Actor Protocol)

<!---------------------------------------------------------------->
Sample Interaction 1:
	// display "Hello World"
	-> ["Hello World"]
	// display two buttons
	-> {"choose a button":{"_btn":{}, "#b1":"Button 1", "#b2":"Button 2"}}
	// first button was clicked
	<- {"#b1":3}
	// give client reward, "Coins Earned"=7, and "Coins Earned" is an integer between 0 and 10, higher is better, and should be removed after 500ms
	->	[{"_nm":{">=":0, "<=":10, "goal":10, "temp":.5}, "Coins Earned":7}]
	// second button was clicked
	<-	{"#b2":3}
	// give reward
	->	{"_.":{"Coins Earned":3}}
	...

Sample Interation 2:
	// display a 100x100 box, with an element inside it that will display red lines
	-> {"click somewhere":{"_xyclick":{}, "#c":{_bx:{w:100,h:100}, "#lines":{_ln:{c:'red'}}}}}
	// user clicked in location 24,60 relative to top-left corner of the box
	<- {"#c":[24,60,3]}
	// draw a line from middle of the box to where user clicked
	-> {"_.":{"#lines":{0:[50,50,24,60]}}}
	// user clicked in location 91,10 relative to top-left corner of the box
	<- {"#c":[91,10,3]}
	// draw a line from middle of the box to where user clicked
	-> {"_.":{"#lines":{1:[50,50,91,10]}}}
	// user clicked in location 31,33 relative to top-left corner of the box
	<- {"#c":[31,33,3]}
	// draw a line from middle of the box to where user clicked
	-> {"_.":{"#lines":{2:[50,50,31,33]}}}
	...

->::= Message sent from task software to participant software
<-::= Message sent to task software from participant software


<!---------------------------------------------------------------->
TASK->ACTOR protocol													//task-server sends information is the following format
<<state>> |																//edit current state recursively with values in <<state>>
{"_.":{<<key>>:<<element>>}}											//find first occurrence of <<key>> in existing hierarchy, edit its value based on <<element>>

ACTOR->TASK protocol													//participant responses to task-server, i.e. action choices
{(<<key>>:<<actionValue>>,)*}


//each key-value pair below is mandatory, unless otherwise stated
<<state>>::= {(<<option>>,)* (<<key>>:<<element>>,)*}
<<state>>::= [(<<element>>,)+]											//[element1, element2] is shorthand for {"0":element1, "1":element2}
<<element>>::= <<state>>|<<text>>|<<number>>|null						//null signifies key deletion
<<key>>::= <<text>> ** must not begin with "_"; empty string not allowed; if key string begins with a number, the number is used for sorting, but stripped from text to be displayed; if key string begins with #, it is not displayed **
**top-level only**
<<option>>::= "_error":<<text>>											//error messages
<<option>>::= "_css":<<url>>											//may be sent once before task begins; may be ignored by computational agents; url of CSS to customize visualization of STAP messages
<<option>>::= "_js":<<url>>												//may be sent once before task begins; may be ignored by computational agents; url of javascript code to customize visualization of STAP messages
<<option>>::= "_replace":{(<<text>>:<<html>>,)+}						//may be sent once before task begins; may be ignored by computational agents; replace shorthand text with longer text/html (can be used for special characters, icons, sound, images, movies, etc.); used to save bandwidth/processing and make things nice looking in gui, rather than to add meaningful information (e.g. to replace certain words with icon equivalents); Example:  {"_replace":{":)":"<img src=smiley.gif>"}} would signify that whenever ":)" is found in text, it is to be replaced with the smiley.gif image
<<option>>::= "_conds":{"(win)|(los)|(end)":[([<<cond>>+],)+]}			//may be sent once before task begins; win, loss, and neutral task-end conditions; assume OR for all items in outer list, assume AND for all items in inner list
<<option>>::= "_A":{(<<key>>:<<actionValue>>,)+}						//auto-select action (e.g. for cruise control, replay/spy, demo, instructions)
**any state**
<<option>>::= "_W":{<<waitID>>:<<number>>}?								//wait flag, used to delay the processing of the current state; <<number>> signifies seconds; following references to the same <<waitID>> either reset the timer, or, if null, destroy the queued message (e.g. "_W":{"0":10} will delay msg processing by 10s, "_W":{"0":.5} will reset the delay on that same msg to 500ms, and "_W":{"0":null} will destroy that msg
<<option>>::= "_C":1|2|3												//optionally clear state; _C:1 = clear all <<key>>:<<element>> pairs; _C:2 = clear all "_W" directives; _C:3 = do both _C:1 and _C:2
<<option>>::= "_nm":{(<<numOption>>,)*}									//these are numeric options (e.g. min, max, flt precision), and apply to state where _nm directive is found, as well as all substates
<<option>>::= "_bx":{(<<divOption>>,)*}									//box formatting options, useful where visualization is task-relevant
<<option>>::= "_ln":{(<<strokeOption>>,)*}								//state that contains this directive is expected to have arrays of numbers as elements for drawing lines, i.e. (<<key>>:[<<number>>,<<number>> (,<<number>>,<<number>>)+],)*
<<option>>::= "_cr":{(<<strokeOption>>,)*}								//state that contains this directive is expected to have arrays of numbers as elements for drawing curves, i.e. (<<key>>:[<<number>>,<<number>> (,<<number>>,<<number>>,<<number>>,<<number>>)+],)*
<<option>>::= {<<inputType>>:{(<<inputOption>>,)*}						//state that contains this directive type is actionable (e.g. clickable)
<<text>>::= ** see JSON specification for string, e.g. http://json.org **
<<number>>::= ** see JSON number specification, e.g. http://json.org **
<<url>>::=	** legal url **
<<html>>::= ** legal text/html **
<<cond>>::= "<<key>>(.<<key>>)* (=|!=|<|>) <<text>>|<<number>>",		//boolean statement signifying a potential game-end condition
<<actionValue>>::= ** must be the same value as what is sent to task from the respective <<inputType>> (e.g. _btn click should be: 3) **
<<waitID>>::= ** any JSON string **
<<numOption>>::= 	("flt":<<number>>) | ("time":<<timeFormat>>) |		//floating point precision or time format; if these parameters are missing, or flt:0, assume this is an int
					"<=":<<number>> |									//minimum value
					">=":<<number>> |									//maximum value
					"goal":<<number>> |									//value actors are seeking in the given task
					"temp":<<number>> |									//temp>0 indicates that this is temporary, rather than cumulative feedback, and should disappear within <<number>> of seconds (e.g. temp reward vs long-term score, the difference being that a temp reward of 1 followed by 0 is fine, whereas a cumulative score of 1 followed by 0 signifies a loss of points)
					"ani":[<<number>>,<<number>>(,<<number>>)]			//[<<number>>,<<number>>,<<number>>] tuple signifies the change in value, time between each change in seconds, and the boundary condition, respectively
<<divOption>>::= 	"w":<<number>>, "h":<<number>> |						//width/height of the box
					"x":<<number>>, "y":<<number>> |					//position of left-top corner of the graphics area
					"r":<<number>> |									//rounded corner radius (ex: create a circle w/ radius=10 -> {"_bx":{"w":20,"h":20,"r":10}})
					"rot":<<number>> |									//rotation
					"bg":<<cssBackground>> |							//background
					"bd":<<cssBorder>> |								//border
					"txt":<<text>> |									//text to be displayed inside the graphics area
					"fnt":<<cssFont>> |									//font for text displayed inside the graphics area
					"txtcol":<<color>> |								//color for text displayed inside the graphics area
					//"opc":<<number>> |								//opacity of the graphics area
					//"scl":<<number>> |								//scale factor for the graphics area
					"ani":<<number>> |									//signifies that w, h, and other divOption values are not set instantly, but rather via animation; <<number>> signifies seconds
					//"anieas":("ease"|"ease-in"|"ease-out"|"ease-in-out")	//easing option for animation; if not specified, animation is linear
<<strokeOption>>::= "f":(<<color>>|"none") |							//similar to SVG fill
					"c":(<<color>>|"none") |							//similar to SVG stroke
					"w":<<number>> |									//similar to SVG stroke-width
					"(start|end)":("arrow"|"circle"|"square"|"") |		//similar to SVG marker-start/marker-end
					"cap":("square"|"round"|"butt") |					//similar to SVG stroke-linecap
					"dash":<<strokeDasharray>>							//similar to SVG stroke-dasharray
<<inputType>>::= 	"_btn"|												//button (default); onclick returns 3
					"_hold"|											//hold down button; onmousedown (or ontouchstart) returns 1, onmouseup (or ontouchend) returns 2
					//"_num"|											//tied to a numspec (TODO: may need options for whether its a slider or text or both)
					"_onoff"|											//boolean choices (e.g. multiple checkboxes or multi-select); when item is selected/on, the return value is 1 (same as mousedown), when item is deselected/off, return value is 2 (same as mouseup)
					"_select"|											//forced choice (e.g. radiobutton, select); onclick returns 3
					"_txt"|												//text input
					"_xyclick"|											//turns _bx elements into clickable areas (e.g. {"_input":{"#X":{"type":"xyclick"}}, "the zone":{"_bx":{"w":400,"h":300,"input":"#X"}}}; would send back tuple [x,y,3], where x,y is the click pos, relative to the top-left corner of the _bx element (e.g. {"#X":[24,60,3]})
					"_xyhold"|											//same as "xyclick", but sends [x,y,1] for mouse-down/touchstart, and [x,y,2] for mouse-up or touchend events
					"_xydrag"|											//same as "bxhold", but assumes that the element is draggable; only valid for interior _bx elements
					"_nav4"|											//4 directions arrow hold-down buttons, sends back "n|s|e|w" for up, down, right, and left
					"_nav8"												//8 directions arrow hold-down buttons, sends back "n|s|e|w", as well as "ns","nw","se","sw"
<<inputOption>>::=	"disabled":0|1 |									//disable/enable input
					"onsubmit":1|0|-1|<<text>> |						//what to do after action is clicked/chosen/submitted: 1: leave as is, 0: disable, -1: clear, <<text>>: replace control with <<text>>
					"keycode":[(<<keycode>>,)+] |						//assigned keyboard shortcuts (e.g. use 13 for carriage return, 65 for A, 37 for left arrow key)
					"multiline":(true|false) |							//if action is txt, this specifies whether carriage returns are allowed in text
					"maxchars":<<number>>								//if action is txt, this specifies max number of characters
					"default":<<text>> |								//default value
<<color>>::= ** see CSS color specification, e.g. http://www.w3schools.com/cssref/css_colors.asp **
<<cssBackground>>::= ** see CSS background specification, e.g. http://www.w3schools.com/cssref/css3_pr_background.asp **
<<cssBorder>>::= ** see CSS border specification, e.g. http://www.w3schools.com/cssref/pr_border.asp **
<<cssFont>>::= ** see CSS font specification, e.g. http://www.w3schools.com/cssref/pr_font_font.asp **
<<strokeDasharray>>::= ** see SVG stroke-dasharray specification, e.g. https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray **
<<keycode>>::= ** javascript key code, e.g. http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes **
, ::= ** commas trailing the last pair in an object or the last element in an array must be trimmed, see JSON members/elements specification, e.g. http://json.org **

